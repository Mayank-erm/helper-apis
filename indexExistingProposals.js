// indexExistingProposals.js// This is a standalone script to index existing Strapi proposals into MeiliSearch.// Save this content as a .js file (e.g., `indexExistingProposals.js`) and run with `node indexExistingProposals.js`const { MeiliSearch } = require('meilisearch');const fetch = require('node-fetch').default;const STRAPI_API_URL = 'http://localhost:1337/api/proposals'; // Your Strapi API URLconst MEILISEARCH_HOST = 'http://localhost:7700';const MEILISEARCH_API_KEY = 'masterKey'; // Use your MeiliSearch master key for indexingconst MEILISEARCH_PROPOSALS_INDEX_UID = 'proposals';const meiliClient = new MeiliSearch({  host: MEILISEARCH_HOST,  apiKey: MEILISEARCH_API_KEY,});/** * Recursively flattens Strapi V4 API response structure. * Converts { id: N, attributes: { ...data } } and relations { data: { id, attributes: {} } } * into a single flat object suitable for MeiliSearch. */function flattenStrapiV4Response(item) {  if (!item || typeof item !== 'object') {    return item;  }  // Handle direct data objects (e.g., from attributes)  if ('id' in item && 'attributes' in item && typeof item.attributes === 'object') {    const flatItem = {      id: item.id,      ...item.attributes,    };    for (const key in flatItem) {      if (Object.prototype.hasOwnProperty.call(flatItem, key)) {        flatItem[key] = flattenStrapiV4Response(flatItem[key]); // Recurse for all attributes      }    }    return flatItem;  }  // Handle nested 'data' objects for relations (single or multiple)  else if ('data' in item && typeof item.data === 'object') {    if (Array.isArray(item.data)) {      // Handle multiple relations (array of data objects)      return item.data.map(relItem => flattenStrapiV4Response(relItem));    } else if (item.data !== null) {      // Handle single relation (a single data object)      return flattenStrapiV4Response(item.data);    } else {      // Handle null data (e.g., optional relation not set)      return null;    }  }  // Handle arrays (e.g., rich text, component arrays)  else if (Array.isArray(item)) {    return item.map(subItem => flattenStrapiV4Response(subItem));  }  // Handle simple objects (e.g., nested components, direct attribute objects)  else if (typeof item === 'object' && item !== null) {    const newObject = {};    for (const key in item) {      if (Object.prototype.hasOwnProperty.call(item, key)) {        newObject[key] = flattenStrapiV4Response(item[key]); // Recurse for all properties      }    }    return newObject;  }  return item; // Return primitive values as is}/** * Manual task polling function as fallback when waitForTask is not available */async function pollTaskStatus(taskId) {  const maxAttempts = 30; // Maximum number of polling attempts  const pollInterval = 1000; // Poll every 1 second    for (let attempt = 0; attempt < maxAttempts; attempt++) {    try {      const taskStatus = await meiliClient.getTask(taskId);            if (taskStatus.status === 'succeeded') {        console.log('Task completed successfully!');        return;      } else if (taskStatus.status === 'failed') {        throw new Error(`Task failed: ${taskStatus.error || 'Unknown error'}`);      }            console.log(`Task status: ${taskStatus.status}, attempt ${attempt + 1}/${maxAttempts}`);            // Wait before next poll      await new Promise(resolve => setTimeout(resolve, pollInterval));          } catch (error) {      if (attempt === maxAttempts - 1) {        throw error;      }      console.log(`Polling attempt ${attempt + 1} failed, retrying...`);      await new Promise(resolve => setTimeout(resolve, pollInterval));    }  }    throw new Error('Task polling timed out');}async function indexAllProposals() {  try {    console.log('Fetching all proposals from Strapi...');        // Use populate=* to fetch all top-level relations and components.    // For deeper nesting, you might need populate[relation_name][populate]=* or specific depth.    const response = await fetch(`${STRAPI_API_URL}?pagination[pageSize]=1000&populate=*`);        if (!response.ok) {      const errorData = await response.json();      throw new Error(`Failed to fetch from Strapi: ${errorData.error?.message || response.statusText}`);    }        const data = await response.json();        // Flatten the Strapi data structure before sending to MeiliSearch    const proposalsToMeiliSearch = data.data.map(item => flattenStrapiV4Response(item));        if (proposalsToMeiliSearch.length === 0) {      console.log('No proposals found in Strapi to index.');      return;    }        const index = meiliClient.index(MEILISEARCH_PROPOSALS_INDEX_UID);        // Option 1: Clear the index first to remove old documents    console.log('Clearing existing documents from MeiliSearch index...');    const deleteTask = await index.deleteAllDocuments();    console.log('Delete task initiated:', deleteTask);        // Wait for deletion to complete before adding new documents    if (deleteTask.taskUid && typeof meiliClient.waitForTask === 'function') {      await meiliClient.waitForTask(deleteTask.taskUid);      console.log('Old documents cleared successfully!');    } else {      // Fallback: wait a bit for deletion to process      console.log('Waiting for deletion to process...');      await new Promise(resolve => setTimeout(resolve, 2000));    }        console.log(`Indexing ${proposalsToMeiliSearch.length} proposals into MeiliSearch index '${MEILISEARCH_PROPOSALS_INDEX_UID}'...`);    const task = await index.addDocuments(proposalsToMeiliSearch); // Add documents to the index        console.log('MeiliSearch indexing task initiated:', task);        // Wait for the task to complete (MeiliSearch v0.51.0 has waitForTask on client)    try {      if (task.taskUid && typeof meiliClient.waitForTask === 'function') {        console.log('Waiting for indexing task completion...');        await meiliClient.waitForTask(task.taskUid);        console.log('MeiliSearch indexing task completed successfully!');      } else {        console.log('waitForTask not available, task initiated successfully.');        console.log('Check MeiliSearch dashboard for completion status.');      }    } catch (waitError) {      console.warn('Could not wait for task completion:', waitError.message);      console.log('Task initiated successfully. Check MeiliSearch dashboard for completion status.');    }      } catch (error) {    console.error('Error during indexing:', error);  }}indexAllProposals();